import type { Course } from './types';

export const mockCourses: Course[] = [
  {
    id: 'android',
    title: 'Android Programming',
    description: 'Learn to build native Android apps from scratch using Kotlin and Jetpack Compose.',
    teacher: 'Rohan Kapoor',
    imageId: 'course-android',
    modules: [
      {
        id: 'android-m1',
        title: 'Kotlin Fundamentals',
        lessons: [
          { id: 'android-l1', title: 'Introduction to Kotlin', type: 'text', content: 'Kotlin is a modern, cross-platform, statically typed, general-purpose programming language with type inference. It is designed to interoperate fully with Java, and the JVM version of Kotlin\'s standard library depends on the Java Class Library, but type inference allows its syntax to be more concise. \n\nKey features we will cover include:\n- **Variables**: `val` for immutable (read-only) variables and `var` for mutable (read-write) variables. You declare them like `val name: String = "John"`.\n- **Basic Data Types**: `Int`, `Double`, `String`, `Boolean`, and `Char`. Kotlin infers the type, so you can often write `val age = 30`.\n- **Null Safety**: Kotlin\'s type system is designed to eliminate the danger of null references, also known as the "billion-dollar mistake". Variables are non-nullable by default. If you need a variable to hold null, you must explicitly declare it as nullable using a `?`, like `var address: String? = null`. This forces you to handle the null case, preventing unexpected crashes.\n- **Control Flow**: We\'ll look at `if-else` as an expression, `when` statements (a more powerful version of Java\'s switch), and loops (`for`, `while`). For example, you can assign the result of an if statement to a variable: `val result = if (a > b) a else b`.' },
          { id: 'android-l2', title: 'Functions and Classes', type: 'text', content: 'In Kotlin, functions are declared with the `fun` keyword. We will explore how to define functions with parameters and return values. For example: `fun sum(a: Int, b: Int): Int { return a + b }`. Classes are blueprints for creating objects, declared with the `class` keyword. This lesson covers creating simple classes with properties and initializers: `class Customer(val name: String)`. We\'ll explore the difference between primary constructors (part of the class header) and secondary constructors (prefixed with `constructor`). We will also introduce data classes, which are a concise way to create classes that just hold data. By adding the `data` keyword, the compiler automatically generates `equals()`, `hashCode()`, `toString()`, `copy()`, and component functions.' },
        ],
      },
      {
        id: 'android-m2',
        title: 'Building User Interfaces',
        lessons: [
          { id: 'android-l3', title: 'Intro to Jetpack Compose', type: 'text', content: "Jetpack Compose is Android's modern, declarative UI toolkit for building native user interfaces. It simplifies and accelerates UI development on Android by allowing you to describe your UI as a set of composable functions. Instead of manipulating a view hierarchy through XML layouts and imperative code, you simply describe what your UI should look like for a given state. When the underlying data (state) changes, Compose automatically and intelligently updates the parts of the UI that have changed, a process known as recomposition. This reactive approach eliminates entire classes of bugs and reduces the amount of boilerplate code you need to write. Composable functions are just regular Kotlin functions annotated with `@Composable`. They emit UI elements and can be nested to create complex UI trees. Core concepts in Compose include Modifiers, which are used to decorate or add behavior (like padding, size, or click listeners) to composables, and State Management, which uses functions like `remember` and `mutableStateOf` to store and observe changes in data that drive the UI. This lesson will provide a foundational understanding of the Compose philosophy and demonstrate how to build simple, dynamic UIs with just a few lines of Kotlin code." },
          { id: 'android-l4', title: 'Layouts, Modifiers, and State', type: 'text', content: 'Compose builds UIs by nesting composable functions. We will learn about core layout components like `Column` (arranges children vertically), `Row` (arranges children horizontally), and `Box` (stacks children on top of each other, like a `FrameLayout`). Modifiers are used to decorate or add behavior to Composables. They are chained together to apply styling, such as `Modifier.padding(16.dp).fillMaxWidth()`. We will also dive into managing UI state using `remember` and `mutableStateOf`. State is any value that can change over time. When state changes, Compose automatically re-runs the relevant composables to update the UI. For example: `var count by remember { mutableStateOf(0) }`.' },
        ],
      },
      {
        id: 'android-m3',
        title: 'App Architecture',
        lessons: [
            { id: 'android-l5', title: 'Activities & Navigation', type: 'text', content: "In traditional Android development, Activities were the primary entry points and containers for an application's UI. While Activities still play a crucial role in modern app architecture—managing the app's process, handling system interactions like the back button, and responding to lifecycle events—their role within the UI has evolved with Jetpack Compose. In a Compose-centric application, you typically have a single Activity that hosts your entire Compose UI. This is known as the 'single-Activity' architecture. Navigation between different screens is then handled entirely within Compose using a navigation library. The official library, Navigation-Compose, provides a `NavHost` composable that acts as a container for your different screen composables. You define a `NavController` to manage the navigation stack and use it to trigger navigation events, such as navigating to a new screen or popping the back stack. Each destination in your navigation graph is a composable function. This approach offers type safety, allows you to pass arguments between screens, and integrates seamlessly with deep linking, making your navigation logic more robust, testable, and easier to manage compared to the older Fragment-based navigation system." },
            { id: 'android-l6', title: 'MVVM with ViewModels', type: 'text', content: 'The Model-View-ViewModel (MVVM) architecture pattern separates UI logic from business logic, improving modularity and testability. \n- **Model**: Represents the data and business logic of the application. \n- **View**: The UI layer (in Compose, this is your composable functions). It observes the ViewModel. \n- **ViewModel**: Acts as a bridge between the Model and the View. It holds UI-related data in a lifecycle-conscious way, meaning it survives configuration changes like screen rotations. We will learn how to use Android\'s `ViewModel` class and expose data to the UI using `StateFlow` or `LiveData` to handle user events and update the UI reactively. This approach leads to more robust and maintainable app code.'}
        ]
      },
    ],
  },
  {
    id: 'python',
    title: 'Python for Everybody',
    description: 'Master the fundamentals of programming with Python 3 and build your first applications.',
    teacher: 'Saanvi Desai',
    imageId: 'course-python',
     modules: [
        {
            id: 'py-m1',
            title: 'Python Fundamentals',
            lessons: [
                { id: 'py-l1', title: 'Introduction to Python', type: 'text', content: "Python is a high-level, interpreted, general-purpose programming language renowned for its simple, clean syntax and powerful capabilities. Created by Guido van Rossum and first released in 1991, Python's design philosophy emphasizes code readability with its notable use of significant whitespace. It is dynamically typed and garbage-collected, supporting multiple programming paradigms, including structured (particularly, procedural), object-oriented, and functional programming. Its extensive standard library, often referred to as 'batteries included,' provides tools suited to many tasks, from web development and data science to scripting and automation. Python's popularity stems from its ease of learning, making it an ideal language for beginners, while also being powerful enough for experts at large companies like Google, Instagram, and Netflix. In this introductory lesson, we will set up your Python environment, write our first 'Hello, World!' program, and explore fundamental concepts such as variables for storing data, basic data types (like integers, floats, strings, and booleans), and how to use the `print()` function to display output. We will also touch upon using comments to document our code, a crucial practice for writing understandable and maintainable programs." },
                { id: 'py-l2', title: 'Data Structures in Python', type: 'text', content: 'Python includes several powerful built-in data structures. \n- **Lists** are ordered, mutable collections that can store items of different types (e.g., `my_list = [1, "hello", 3.14]`). They support indexing and slicing. \n- **Tuples** are ordered and immutable, often used for data that should not change after creation. They are created with parentheses: `my_tuple = (1, "hello", 3.14)`. \n- **Dictionaries** are unordered collections of key-value pairs, perfect for storing related information. Keys must be unique and immutable. Example: `my_dict = {"name": "John", "age": 30}`. \n- **Sets** are unordered collections of unique items. They are useful for membership testing and eliminating duplicates efficiently. Example: `my_set = {1, 2, 3}`. Mastering these is essential for organizing and storing data efficiently in any Python program.'}
            ]
        },
        {
            id: 'py-m2',
            title: 'Control Flow and Functions',
            lessons: [
              { id: 'py-l3', title: 'Conditional Statements and Loops', type: 'text', content: "Control flow is the cornerstone of programming logic, allowing a program to make decisions and perform repetitive tasks. In Python, this is primarily achieved through conditional statements and loops. Conditional statements, using `if`, `elif` (else if), and `else`, allow your program to execute different blocks of code based on whether certain conditions are true or false. This enables decision-making within your code. For example, you can check a user's input, validate data, or respond differently based on a variable's value. We will explore comparison operators (like `==`, `!=`, `>`, `<`) and logical operators (`and`, `or`, `not`) to build complex conditions. Loops, on the other hand, are used to execute a block of code repeatedly. The `for` loop is used for iterating over a sequence (such as a list, tuple, dictionary, set, or string). It's perfect for when you know how many times you want to iterate. The `while` loop repeats as long as a certain boolean condition is met. It's ideal for situations where you don't know in advance how many times the loop will need to run, such as waiting for user input. We will also cover loop control statements like `break` to exit a loop early and `continue` to skip the current iteration and proceed to the next." },
              { id: 'py-l4', title: 'Writing Your Own Functions', type: 'text', content: 'Functions are reusable blocks of code that perform a specific task, defined using the `def` keyword. They help to make your code more modular, organized, and easier to debug by breaking down complex problems into smaller, manageable pieces. We will cover how to define functions, pass arguments (including positional and keyword arguments), and use the `return` statement to send a value back. We will also touch on default parameter values (e.g., `def greet(name="Guest")`) and the concept of variable scope (local vs. global variables).'}
            ]
        }
    ]
  },
  {
    id: 'cybersecurity',
    title: 'Cybersecurity Essentials',
    description: 'Learn the fundamentals of cybersecurity, including threat analysis and network security.',
    teacher: 'Dr. Ananya Sharma',
    imageId: 'course-cyber',
     modules: [
        {
            id: 'cs-m1',
            title: 'Introduction to Cybersecurity',
            lessons: [
                { id: 'cs-l1', title: 'The Threat Landscape', type: 'text', content: "The modern digital threat landscape is a complex and constantly evolving ecosystem of adversaries, attack vectors, and vulnerabilities. Understanding this landscape is the first step toward building an effective cybersecurity defense. Adversaries, or threat actors, range from individual hobbyist hackers (script kiddies) and politically motivated hacktivists to organized cybercrime syndicates seeking financial gain and highly sophisticated, state-sponsored groups conducting espionage or sabotage. Each has different motivations, resources, and levels of skill. Their methods of attack, known as attack vectors, are equally diverse. These include technical exploits like malware (viruses, ransomware, spyware), phishing attacks designed to steal credentials through social engineering, denial-of-service (DoS) attacks aimed at overwhelming services to make them unavailable, and Man-in-the-Middle (MitM) attacks to eavesdrop on communications. Vulnerabilities are the weaknesses in systems, processes, or controls that these actors exploit, which can range from unpatched software and weak passwords to a lack of employee security awareness. The landscape is further complicated by emerging technologies like IoT (Internet of Things), which introduces billions of new, often insecure, devices to the network, and the increasing reliance on cloud services, which shifts the security responsibilities and introduces new potential points of failure. A comprehensive understanding of these elements is crucial for anticipating threats and implementing layered security measures to protect digital assets." },
                { id: 'cs-l2', title: 'Core Security Principles (CIA Triad)', type: 'text', content: 'The CIA Triad (Confidentiality, Integrity, Availability) is a foundational model for guiding information security policies. \n- **Confidentiality** ensures that sensitive information is not disclosed to unauthorized individuals, entities, or processes. Common tools for this include encryption, access control lists (ACLs), and data classification. \n- **Integrity** ensures the accuracy and completeness of data over its entire lifecycle. This means data cannot be modified in an unauthorized or undetected manner. Hashing functions (like SHA-256) are a key tool to verify file integrity. \n- **Availability** ensures that data and services are accessible when needed by authorized users. This involves protecting against hardware failures, network outages, and Denial-of-Service (DoS) attacks. Redundancy, backups, and disaster recovery plans are critical for maintaining availability. Understanding this triad is crucial for identifying vulnerabilities and implementing effective security measures.'}
            ]
        },
        {
            id: 'cs-m2',
            title: 'Network & Web Security',
            lessons: [
              { id: 'cs-l3', title: 'Common Web Attacks', type: 'text', content: 'Web applications are common targets for attackers. \n- **Cross-Site Scripting (XSS)** involves injecting malicious scripts into trusted websites, which then execute on a victim\'s browser. This can be used to steal cookies or session tokens. \n- **SQL Injection (SQLi)** is an attack where malicious SQL code is inserted into a query to manipulate a database, potentially exposing sensitive data, modifying data, or executing administrative operations. \n- **Cross-Site Request Forgery (CSRF)** tricks a victim into submitting a malicious request they did not intend to. For example, forcing a logged-in user to transfer funds. Understanding how these attacks work is the first step to preventing them through proper input validation, output encoding, parameterized queries (prepared statements), and using anti-CSRF tokens.' },
              { id: 'cs-l4', title: 'Firewalls and Intrusion Detection', type: 'text', content: 'A Firewall acts as a barrier between a trusted internal network and an untrusted external network (like the internet). It works by analyzing data packets and determining whether they should be allowed through based on a pre-determined set of rules. An Intrusion Detection System (IDS) is a device or software application that monitors a network or systems for malicious activity or policy violations. Any detected activity is typically reported either to an administrator or collected centrally using a security information and event management (SIEM) system. An Intrusion Prevention System (IPS) is an extension of an IDS that can also actively block or prevent the detected threat.'}
            ]
        }
    ]
  },
  {
    id: 'dcn',
    title: 'Data Communication and Networking',
    description: 'Understand how data travels across networks, from physical links to application protocols.',
    teacher: 'Vikram Singh',
    imageId: 'course-dcn',
    modules: [
        {
            id: 'dcn-m1',
            title: 'Foundations of Networking',
            lessons: [
                { id: 'dcn-l1', title: 'What is a Computer Network?', type: 'text', content: "A computer network, at its core, is a collection of interconnected computing devices that can exchange data and share resources with each other. These devices, known as nodes, can include everything from personal computers, servers, and smartphones to printers, cameras, and IoT sensors. The connections between these nodes are established through a communication medium, which can be wired (using Ethernet cables, fiber optic cables) or wireless (using radio waves like Wi-Fi, Bluetooth, or cellular signals). The fundamental purpose of a network is to facilitate communication and resource sharing. This can be as simple as sharing a file between two computers or as complex as the global internet, which connects billions of devices worldwide. Networks are categorized by their scale. A Local Area Network (LAN) covers a small geographical area like a home, office, or school. A Wide Area Network (WAN) connects multiple LANs over a large geographical distance, often using leased telecommunication lines. The Internet is the largest example of a WAN. For these devices to communicate effectively, they must follow a set of rules, or protocols, which define the format, order, and meaning of the messages exchanged. Key networking hardware includes switches (to connect devices within a LAN), routers (to connect different networks and forward data between them), and access points (to allow wireless devices to connect to a wired network)." },
                { id: 'dcn-l2', title: 'The OSI Model Explained', type: 'text', content: 'The Open Systems Interconnection (OSI) model is a conceptual framework that standardizes the functions of a computing system into seven abstract layers. \n1. **Physical Layer**: Transmits raw bits over a physical medium (cables, radio waves). Deals with voltage levels, pin layouts, and cable specifications. \n2. **Data Link Layer**: Organizes bits into frames and handles error detection and correction from the physical layer. It contains two sub-layers: MAC (Media Access Control) and LLC (Logical Link Control). MAC addresses are used here. \n3. **Network Layer**: Responsible for logical addressing (IP addresses) and routing packets from source to destination across multiple networks. \n4. **Transport Layer**: Provides reliable data transfer between end systems. The two main protocols are TCP (Transmission Control Protocol), which is connection-oriented and reliable, and UDP (User Datagram Protocol), which is connectionless and faster but less reliable. \n5. **Session Layer**: Manages, establishes, and terminates sessions between applications. \n6. **Presentation Layer**: Translates, encrypts, and compresses data. It ensures data is in a usable format for the Application layer. \n7. **Application Layer**: Provides network services directly to the user\'s applications, such as HTTP, FTP, and SMTP. \nThis model helps in understanding and troubleshooting network problems by providing a clear separation of functions.'}
            ]
        },
        {
            id: 'dcn-m2',
            title: 'The TCP/IP Protocol Suite',
            lessons: [
                { id: 'dcn-l3', title: 'Understanding TCP and UDP', type: 'text', content: "In the Transport Layer of the networking model, two primary protocols govern how data is moved between applications: the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP). They serve different purposes and have distinct characteristics. TCP is a connection-oriented protocol, meaning it establishes a reliable, three-way handshake between the sender and receiver before any data is sent. It is designed for reliability. TCP guarantees that data packets will be delivered in the correct order, without errors, and without any data loss. It achieves this through mechanisms like sequence numbers, acknowledgments (ACKs), and retransmission of lost packets. This reliability makes TCP ideal for applications where data integrity is paramount, such as web browsing (HTTP/HTTPS), email (SMTP), and file transfers (FTP). However, this reliability comes at the cost of higher overhead and slower speeds. In contrast, UDP is a connectionless protocol. It is simple, fast, and lightweight. UDP sends packets of data, called datagrams, without establishing a connection first and without any guarantee of delivery, order, or error-checking. It's a 'fire-and-forget' protocol. This low overhead makes UDP perfect for real-time applications where speed is more critical than perfect accuracy. Examples include live video and audio streaming, online gaming, and DNS (Domain Name System) lookups. In these cases, losing a single packet is often preferable to waiting for a retransmission, which would cause noticeable lag or jitter." },
                { id: 'dcn-l4', title: 'IP Addressing and Subnetting', type: 'text', content: 'An Internet Protocol (IP) address is a numerical label assigned to each device connected to a computer network that uses the Internet Protocol for communication. IPv4 addresses are 32 bits long, often shown as four decimal numbers separated by dots (e.g., 192.168.1.1). Subnetting is the practice of dividing a network into two or more smaller networks (subnets). This is done by "borrowing" bits from the host portion of the IP address to create a subnet mask. This increases security by isolating networks, improves performance by reducing the size of the broadcast domain, and helps to more efficiently manage a limited number of IP addresses. We will learn how to calculate subnets and assign IP addresses effectively.'}
            ]
        }
    ]
  }
];

    
    